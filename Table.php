<?php

namespace SnooPHP\Model;

/**
 * A table is used to create a migration plan
 * 
 * @author sneppy
 */
class Table
{
	/**
	 * @var string $name table name
	 */
	protected $name;

	/**
	 * @var array $columns array of columns
	 */
	protected $columns = [];

	/**
	 * @var array $dependencies list of table dependencies
	 */
	protected $dependencies = [];

	/**
	 * Create a new table (doesn't run CREATE TABLE)
	 * 
	 * @param string $model class of the model or name of the table 
	 */
	public function __construct($model)
	{
		$this->name = class_exists($model) ? $model::tableName() : $model;
	}

	/**
	 * Get name
	 * 
	 * @return string
	 */
	public function name()
	{
		return $this->name;
	}

	/**
	 * Get columns
	 * 
	 * @return Column[]
	 */
	public function columns()
	{
		return $this->columns;
	}

	/**
	 * Attemp to create a table with 'create table' instruction
	 * 
	 * @return bool false if fails
	 */
	public function create()
	{
		return Db::query($this->createQuery()) !== false;
	}

	/**
	 * Drop the table
	 * 
	 * @return bool false if fails
	 */
	public function drop()
	{
		return Db::query("drop table if exists ".$this->name) !== false;
	}

	/**
	 * Return true if depends on some table
	 * 
	 * @return bool
	 */
	public function dependent()
	{
		return count($this->dependencies) > 0;
	}

	/**
	 * Compute dependencies
	 * 
	 * Compute dependencies based on column
	 * Used to build dependency treea and compute migration order
	 * 
	 * @return array
	 */
	public function generateDependencies()
	{
		foreach ($this->columns as $column)
		{
			// Dependencies in most cases are generated by foreign keys
			if ($foreign = $column->property("foreign"))
			{
				$this->dependencies[] = $foreign["table"];
			}
		}

		// Remove duplicate dependencies
		$this->dependencies = array_unique($this->dependencies);
		return $this->dependencies;
	}

	/**
	 * Remove satisfied dependency and return new list
	 * 
	 * @param string $table dependency to remove
	 * 
	 * @return array
	 */
	public function removeDependency($table)
	{
		foreach ($this->dependencies as $i => $dependency)
		{
			if ($dependency === $table)
			{
				unset($this->dependencies[$i]);
				break;
			}
		}

		return $this->dependencies;
	}

	/**
	 * Add an auto increment primary column
	 * 
	 * @param string	$name	column name (default id)
	 * @param int		$size	integer size (default 16)
	 */
	public function id($name = "id", $size = 16)
	{
		$this->add($name, "int")->size(16)->unsigned()->autoIncrement()->primary();
	}

	/**
	 * Adds created and modified timestamps
	 */
	public function timestamps()
	{
		$this->timestamp("created_at")->onUpdate();
		$this->timestamp("updated_at")->onUpdate();
	}

	/**
	 * Add a string (varchar) column with an optional size
	 * 
	 * @param string	$name	column name
	 * @param int		$size	optional size
	 * 
	 * @return Column
	 */
	public function string($name, $size = 255)
	{
		return $this->add($name, "varchar")->size($size);
	}

	/**
	 * Add an integer column with an optional size
	 * 
	 * @param string	$name	column name
	 * @param int		$size	optional size
	 * 
	 * @return Column
	 */
	public function integer($name, $size = 16)
	{
		return $this->add($name, "int")->size($size);
	}

	/**
	 * Alias for integer
	 * 
	 * @see integer()
	 */
	public function int($name, $size = 16)
	{
		return $this->integer($name, $size);
	}

	/**
	 * Add an unsigned int column with an optional size
	 * 
	 * @param string	$name	column name
	 * @param int		$size	optional size
	 * 
	 * @return Column
	 */
	public function uint($name, $size = 16)
	{
		return $this->add($name, "int")->size($size)->unsigned();
	}

	/**
	 * Add a boolean column (using TINYINT(1))
	 * 
	 * @param string	$name	column name
	 * 
	 * @return Column
	 */
	public function bool($name)
	{
		return $this->add($name, "bool");
	}

	/**
	 * Add a timestamp column
	 * 
	 * @param string $name column name
	 * 
	 * @return Column
	 */
	public function timestamp($name)
	{
		return $this->add($name, "timestamp")->default("current_timestamp");
	}

	/**
	 * Add a json column
	 * 
	 * @param string $name column name
	 * 
	 * @return Column
	 */
	public function json($name)
	{
		return $this->add($name, "json");
	}

	/**
	 * Get query string
	 * 
	 * @return string
	 */
	public function createQuery()
	{
		$query			= "create table {$this->name}(\n\t";
		$columns		= [];
		$constraints	= [];
		foreach ($this->columns as $column)
		{
			$name = $column->name();

			// Columns
			$columns[] = $column->declaration();

			// Constraints
			if ($column->property("unique")) $constraints[] = "constraint UK_".$this->name()."_".$name." unique key (".$name.")";
			if ($column->property("primary")) $constraints[] = "constraint PK_".$this->name()."_".$name." primary key (".$name.")";
			if ($foreign = $column->property("foreign")) $constraints[] = "constraint FK_".$this->name()."_".$name." foreign key (".$name.") references ".$foreign["table"]."(".$foreign["column"].")".($foreign["onDelete"] ? " on delete ".$foreign["onDelete"] : "").($foreign["onUpdate"] ? " on update ".$foreign["onUpdate"] : "");

			// Composite keys
			if ($column->property("uniqueComposite") !== null)
			{
				$uniqueChain[] = $column;
				// Close chain
				if ($column->property("uniqueComposite") === true)
				{
					$compositeKey = array_map(function($column) {
	
						return $column->name();
					}, $uniqueChain);
	
					$constraints[] = "constraint UK_{$this->name}_".implode("_", $compositeKey)." unique key (".implode(", ", $compositeKey).")";
					$uniqueChain = [];
				}
			}
			if ($column->property("primaryComposite") !== null)
			{
				$primaryChain[] = $column;
				// Close chain
				if ($column->property("primaryComposite") === true)
				{
					$compositeKey = array_map(function($column) {
	
						return $column->name();
					}, $primaryChain);
	
					$constraints[] = "constraint PK_{$this->name}_".implode("_", $compositeKey)." primary key (".implode(", ", $compositeKey).")";
					$primaryChain = [];
				}
			}
			if ($foreign = $column->property("foreignComposite") !== null)
			{
				$foreignChain[] = $column;
				// Close chain
				if ($foreign["closeChain"] === true)
				{
					$compositeKey = [];
					$compositeRef = [];
					foreach ($foreignChain as $column)
					{
						$compositeKey[] = $column->name();
						$compositeRef[] = $column->property("foreignComposite")["column"];
					}
	
					$onDelete = $foreign["onDelete"];
					$onUpdate = $foreign["onUpdate"];
					$refTable = $foreign["table"];
	
					$constraints[] = "constraint FK_{$this->name}_".implode("_", $compositeKey)." foreign key (".implode(", ", $compositeKey).") references $refTable(".implode(", ", $compositeRef).") on delete $onDelete on update $onUpdate";
					$foreignChain = [];
				}
			}
		}
		
		// Build query
		return $query.implode(",\n\t", array_merge($columns, $constraints))."\n);";
	}

	/**
	 * Add column to table
	 * 
	 * @param string	$name	column name
	 * @param string	$type	column type
	 * 
	 * @return Column added column
	 */
	public function add($name, $type)
	{
		$column = new Column($name, $type);
		$this->columns[] = $column;
		return $column;
	}
}

/**
 * A column is a field of a table with a type and optional properties
 * 
 * @author sneppy
 */
class Column
{
	/**
	 * @var string $name column name
	 */
	protected $name;

	/**
	 * @var string $type column type
	 */
	protected $type;

	/**
	 * @var array $properties column properties
	 */
	protected $properties;

	/**
	 * Create a column
	 * 
	 * @param string	$name		column name
	 * @param string	$type		column type
	 * @param array		$properties	column properties
	 */
	public function __construct($name, $type, array $properties = [])
	{
		$this->name	= $name;
		$this->type	= $type;
	}

	/**
	 * Get column name
	 * 
	 * @return string
	 */
	public function name()
	{
		return $this->name;
	}

	/**
	 * Get column type
	 * 
	 * @return string
	 */
	public function type()
	{
		$size = ($size = $this->property("size")) ? "(".$size.")" : "";
		return strtolower($this->type).$size;
	}

	/**
	 * Get column property(ies)
	 * 
	 * @param string $name if specified return property
	 * 
	 * @return array|string|null return null if property is not found
	 */
	public function property($name = null)
	{
		return !$name ? $this->properties : (
			isset($this->properties[$name]) ? $this->properties[$name] : (
				null
			)
		);
	}

	/**
	 * Set nullable or not nullable
	 * 
	 * @return Column
	 */
	public function notNullable()
	{
		return $this->set("notNullable");
	}

	/**
	 * Explicity set this column to be nullable
	 * 
	 * This is require in certain situations, for example with timestamp columns
	 * 
	 * @return Column
	 */
	public function nullable()
	{
		return $this->set("nullable");
	}

	/**
	 * Set data size
	 * 
	 * @param int $value column data size
	 * 
	 * @return Column
	 */
	public function size($value)
	{
		return $this->set("size", $value);
	}

	/**
	 * Set default
	 * 
	 * @param mixed $value default value for column
	 * 
	 * @return Column
	 */
	public function default($value)
	{
		return $this->set("default", $value);
	}

	/**
	 * Set unsigned
	 * 
	 * @return Column
	 */
	public function unsigned()
	{
		return $this->set("unsigned");
	}

	/**
	 * Set auto increment
	 * 
	 * @return Column
	 */
	public function autoIncrement()
	{
		return $this->set("autoIncrement");
	}

	/**
	 * Set on update property of timestamp
	 * 
	 * @param mixed $value value to set on table update
	 * 
	 * @return Column
	 */
	public function onUpdate($value = "current_timestamp")
	{
		return $this->set("onUpdate", $value);
	}

	/**
	 * Make unique key
	 * 
	 * @return Column
	 */
	public function unique()
	{
		return $this->set("unique");
	}

	/**
	 * Make composite unique key
	 * 
	 * @param bool $closeChain close composite chain
	 * 
	 * @return Column
	 */
	public function uniqueComposite($closeChain = false)
	{
		return $this->set("uniqueComposite", $closeChain);
	}

	/**
	 * Make primary key
	 * 
	 * @return Column
	 */
	public function primary()
	{
		return $this->set("primary");
	}

	/**
	 * Make composite primary key
	 * 
	 * @param bool $closeChain close composite chain
	 * 
	 * @return Column
	 */
	public function primaryComposite($closeChain = false)
	{
		return $this->set("primaryComposite", $closeChain);
	}

	/**
	 * Make foreign key
	 * 
	 * @param string		$table		name of foreign table
	 * @param string		$column		name of foreign column
	 * @param string|null	$onDelete	on delete option
	 * @param string|null	$onUpdate	on update option
	 * 
	 * @return Column
	 */
	public function references($table, $column, $onDelete = "no action", $onUpdate = "no action")
	{
		return $this->set("foreign", [
			"table"		=> $table,
			"column"	=> $column,
			"onDelete"	=> $onDelete ? strtolower($onDelete) : null,
			"onUpdate"	=> $onUpdate ? strtolower($onUpdate) : null
		]);
	}

	/**
	 * Make composite foreign key
	 * 
	 * @param string		$column		name of foreign column
	 * @param bool			$closeChain close composite chain
	 * @param string		$table		name of foreign table
	 * @param string|null	$onDelete	on delete option
	 * @param string|null	$onUpdate	on update option
	 * 
	 * @return Column
	 */
	public function referencesComposite($column, $closeChain = false, $table = "table", $onDelete = "no action", $onUpdate = "no action")
	{
		return $this->set("foreignComposite", [
			"closeChain"	=> $closeChain,
			"table"			=> $table,
			"column"		=> $column,
			"onDelete"		=> $onDelete,
			"onUpdate"		=> $onUpdate
		]);
	}

	/**
	 * Return column declaration (no constraints)
	 * 
	 * @return string
	 */
	public function declaration()
	{
		$name = $this->name();
		$type = $this->type();

		$unsigned		= $this->property("unsigned");
		$notNullable	= $this->property("notNullable");
		$nullable		= $this->property("nullable");
		$default		= $this->property("default");
		$autoIncrement	= $this->property("autoIncrement");
		$properties		=
			($unsigned ? "unsigned " : "")						.
			($notNullable ? "not null " : "")					.
			($nullable ? "null " : "")							.
			($default !== null ? "default {$default} " : "")	.
			($autoIncrement ? "auto_increment " : "")			;

		return trim($name)." ".trim($type)." ".trim($properties);
	}

	/**
	 * Set column property
	 * 
	 * @param string	$name	name of the property
	 * @param mixed		$value	value of the property if necessary
	 * 
	 * @return Column
	 */
	protected function set($name, $value = true)
	{
		$this->properties[$name] = $value;
		return $this;
	}
}